
__all__ = [
    "cal_L",
    "cal_L_approx",
    "save_spfd_coil",
    "conv_XYZ_trimesh",
    "conv2Points",
    "load_mesh_file"
]

import numpy as np
import trimesh
import os

def cal_L(loops,radius=1e-3):
    # loops is the object generated by bfield tools
    Mself = loops.line_mutual_inductance(loops,separate_loops=True, radius=radius)
    # print("Inductance based on r=1mm wire", np.sum(Mself)*1e6, "uH")
    return np.sum(Mself)

def cal_L_approx(stream_function,N_coutours):
    # coil's stream function
    sf = stream_function
    scaling = N_coutours / (sf.max() - sf.min())
    L_approx = 2 * sf.magnetic_energy * (scaling ** 2)
    # print("Inductance based on the continuous current density", L_approx)
    return L_approx

# def save_spfd_coil()

def save_spfd_coil(file_name,loops,current_strength=1000,zero_offset=0.0):
    ## input: file_name: the file name you want to save as, e.g.'bfield_coil.csv'
    ##        loops:     the bfieldtools loops object
    ##        current_strength: current strength writing to first colmun
    ##        zero_offset: unit: (m) sometimes in order to avoid r=0 in bfieldtools,
    ##              a zero_offset was added both to target and source,
    import csv,os,sys
    try:
        if os.path.exists(file_name):
            print('File already exist, please delete it')
        else:
            with open(file_name, 'w', newline='') as file:
                writer = csv.writer(file)
                coil_winding=[]
                for i in range(len(loops.entities)):
                    xyz = loops.entities[i].discrete(loops.vertices)
                    xyz[:,2] -= zero_offset
                    flat_xyz = xyz.flatten()
                    coil_winding.append(flat_xyz)
                    one_line  = np.concatenate([[current_strength],flat_xyz]).flatten()
                    writer.writerow(one_line)
            print("csv file saved with current strength: "+ str(current_strength) +"A")
    except:
        print("Unexpected error:", sys.exc_info()[0])
        raise

# todo, save coil obj function after optimization
def gen_rect_faces(numRow,numCol):
    # may able to simplified by np.lib.stride_tricks.as_strided
    faces = []
    idx_mat = np.arange(numRow*numCol).reshape(numRow,numCol)
    for i in range(numRow-1):
        for j in range(numCol-1):
            faces.append([idx_mat[i,j],idx_mat[i+1,j],idx_mat[i,j+1]])
            faces.append([idx_mat[i+1,j],idx_mat[i+1,j+1],idx_mat[i,j+1]])
    return np.array(faces)

def conv2Points(X,Y,Z):
    # return xyz array with shape (:,3)
    return np.array([X.ravel(), Y.ravel(), Z.ravel()]).T

def conv_XYZ_trimesh(X,Y,Z):
    # inputs: X,Y,Z potins
    # outpus: trimesh object
    numX,numY = X.shape
    points = conv2Points(X,Y,Z)
    faces = gen_rect_faces(numX,numY)
    return trimesh.Trimesh(points,faces)



def load_mesh_file(mesh_name, mesh_dir=None,process=True,**kwargs):
    """
    rewrited from bfieldtools.util.load_example_mesh
    Convenience function used load example meshes included with the package

    Parameters
    ----------
    mesh_name: strings
        name of mesh, i.e. filename without extension
    mesh_dir: strings
            dir which contain mesh, default is './'
    process: Boolean
        Whether trimesh should process the mesh on loading
    kwargs
        Passed to trimesh object creation

    Returns
    -------
    Trimesh object
    """

    if mesh_dir is None:
        mesh_dir = './'
        print('scaning readable files in current folder:')
    # Filter according to file extension
    existing_files = [file for file in os.listdir(mesh_dir)]
    existing_files = [
        file
        for file in existing_files
        if file.lower().endswith(tuple(trimesh.exchange.load.mesh_formats()))
    ]

    # Remove file extension to get name
    existing_names = [os.path.splitext(file)[0] for file in existing_files]
    # print(existing_names)

    # Check if name exists
    if mesh_name not in existing_names:
        print("readable files name:")
        print(existing_names)
        raise ValueError(
            "Mesh with name %s not found in folder" % mesh_name
        )

    filename = existing_files[existing_names.index(mesh_name)]
    print(filename)

    return trimesh.load(
        os.path.join(mesh_dir, filename),
        process=process,
        **kwargs
    )
